# C++基础知识总结：

1. struct和class的区别?
- 默认的继承访问权限
- 混搭的时候，该权限取决于派生类而非基类
- class 可用于定义模板参数，struct不能 
- struct 的存在主要考虑向下兼容性

2. 一个空类，会生成哪些成员？
- 未使用时只有一个字节的占位符
- 使用是会生成默认构造、析构、拷贝构造、赋值运算符、取值，this指针
- 皆为inline和公有

3. 必须在构造函数初始化式里进行初始化的数据成员有哪些？
- 常量成员、引用成员、对象成员

4. 说一下虚函数吧？
- 作用是为了实现多态,通过家virtual关键字实现
- 基类定义虚函数，派生类重写虚函数
- 虚函数只能借助于指针或引用达到多态效果
- 当虚函数被赋值为0的时候为纯虚函数	

5. static用法
- 拓展生存期(程序的生存期，而非作用域）
- 限制作用域(作用于该文件所限制作用域）
- 唯一性(属于一个类而不属于任何对象的变量或函数）

6. C和C++的区别
- C面向过程，C++面向对象,包含封装、继承、多态
- C++是C的超集，包含大多数C的特性
- C++增加了异常、类型检查、泛型、重载等特性
- 内存分配new(delete),malloc(free)

7. 堆和栈的区别
- 栈：编译器自动分配释放，存放函数变量值，局部变量等,操作方式类似于数据结构中的栈
- 堆：malloc分配,free释放,存放全局变量，操作方式类似于链表

8. 说一下new和malloc的区别
- 申请内存所在位置不同 new从自由存储区分配， malloc在堆上分配
- 返回类型安全性 new返回对象指针，无需类型转换，malloc返回void*，需要强制类型转换
- 分配失败时 new 返回bad_alloc异常，malloc 返回NULL
- 大小 new无需指定内存大小，malloc需要指定
- new调用构造/析构函数初始化对象，malloc不调用
- new允许函数重载，malloc不允许
- new的实现基于malloc

9. 哪些操作符不可以重载？
- .（成员访问运算符）
- .*,->*（成员指针访问运算符）
- ::（域运算符）
- sizeof（长度运算符）
- ?:（条件运算符）
- #（预处理运算符）
- 前两个运算符不能重载是为了保证访问成员的功能不能被改变，
域操作符和sizeof运算符的运算对象是类型而不是一般变量或表达式
不具备重载功能

10. 你了解编译的过程吗？
- 预编译 (展开头文件/宏文件/去掉注释/条件编译） (.i)
- 编译 （检查语法，生成汇编）（.s)
- 汇编（汇编代码转机器码）(.o)
- 链接 （链接到一起，生成可执行程序）

11. 指针和引用的异同
- 都是间接参考其他对象
- 操作符不同：指针"->,*"; 引用"."
- 指针一般指某块内存的地址，引用是一个变量的别名 
- 指针可以为空，引用不能为空
- 指针可以多次赋值，引用从一而终

12. C++中四种强制类型转换的区别
- const_cast 常量指针或引用转化为非常量，并仍然指向原来对象
- static_cast 可用于基本的数据类型，派生类指针或引用转化为基类的指针或引用（向上）
- dynamic_cast 派生类的指针或引用和基类指针或引用的相互转换(向上、向下），其他三种是编译时完成，dynamic_cast
是运行时完成，基类要有虚函数
- reinterpret_cast 可以在任何类型之间进行转换

13. C++中，分别简述封装，继承，多态
- 封装：面向对象重要原则，是把对象的属性和行为（方法）结合为一个独立的整体，并尽可能的隐藏对象的内部实现细节，所以起到了增加安全性的作用
- 继承：面向对像的显著特性，是从已有类中派生出新的类，称之为子类，子类继承父类继承并扩展父类的属性和行为；提高了代码的复用性
- 多态：多态允许不同的对象对同一个消息做出响应，即同一个消息可以根据发送对像的不同而采取多种不同的行为方式 
