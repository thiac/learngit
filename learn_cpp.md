# C++基础知识总结：

1. struct和class的区别?
- 默认的继承访问权限
- 混搭的时候，该权限取决于派生类而非基类
- class 可用于定义模板参数，struct不能 
- struct 的存在主要考虑向下兼容性

2. 一个空类，会生成哪些成员？
- 未使用时只有一个字节的占位符
- 使用是会生成默认构造、析构、拷贝构造、赋值运算符、取值，this指针
- 皆为inline和公有

3. 必须在构造函数初始化式里进行初始化的数据成员有哪些？
- 常量成员、引用成员、对象成员

4. 说一下虚函数吧？
- 作用是为了实现多态,通过家virtual关键字实现
- 基类定义虚函数，派生类重写虚函数
- 虚函数只能借助于指针或引用达到多态效果
- 当虚函数被赋值为0的时候为纯虚函数	

5. static用法
- 拓展生存期(程序的生存期，而非作用域）
- 限制作用域(作用于该文件所限制作用域）
- 唯一性(属于一个类而不属于任何对象的变量或函数）

6. C和C++的区别
- C面向过程，C++面向对象,包含封装、继承、多态
- C++是C的超集，包含大多数C的特性
- C++增加了异常、类型检查、泛型、重载等特性
- 内存分配new(delete),malloc(free)

7. 堆和栈的区别
- 栈：编译器自动分配释放，存放函数变量值，局部变量等,操作方式类似于数据结构中的栈
- 堆：malloc分配,free释放,存放全局变量，操作方式类似于链表

8. 说一下new和malloc的区别
- 申请内存所在位置不同 new从自由存储区分配， malloc在堆上分配
- 返回类型安全性 new返回对象指针，无需类型转换，malloc返回void*，需要强制类型转换
- 分配失败时 new 返回bad_alloc异常，malloc 返回NULL
- 大小 new无需指定内存大小，malloc需要指定
- new调用构造/析构函数初始化对象，malloc不调用
- new允许函数重载，malloc不允许
- new的实现基于malloc

9. 哪些操作符不可以重载？
- .（成员访问运算符）
- .*,->*（成员指针访问运算符）
- ::（域运算符）
- sizeof（长度运算符）
- ?:（条件运算符）
- #（预处理运算符）
- 前两个运算符不能重载是为了保证访问成员的功能不能被改变，
域操作符和sizeof运算符的运算对象是类型而不是一般变量或表达式
不具备重载功能
